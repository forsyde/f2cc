<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TinyXml: TinyXML++</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="index.html">index</a>      </li>
      <li><a class="el" href="ticppTutorial.html">TinyXML++ Tutorial</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>TinyXML++ </h1>  </div>
</div>
<div class="contents">
<h2>General Concepts </h2>
<p>The TinyXML++ classes are all wrappers around the corresponding classes within TinyXML.</p>
<p>There is no reason to create TinyXML++ objects on the heap, using <code>new</code>, because the memory is managed for you. If you choose to use <code>new</code> to create TinyXML++ objects, you will <b>always</b> need to use <code>delete</code> to clean up.</p>
<p>Basically, TinyXML++ objects are just wrappers around TinyXML pointers.</p>
<h2>Goals </h2>
<ul>
<li>Simplify the use and interface of TinyXml, using C++ concepts.<ul>
<li>Use exceptions for error handling, so there are no return codes to check</li>
<li>Use templates for automatic type conversion</li>
<li>Use STL style iterators to move through nodes and attributes</li>
</ul>
</li>
</ul>
<h2>Details </h2>
<h3>Use exceptions for error handling </h3>
<p>When using the original TinyXML, every function returns a value indicating success or failure. A programmer would have to check that value to ensure the function succeeded.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> Load a document
<a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a> doc( pFilename );
<span class="keywordflow">if</span> ( !doc.LoadFile() ) <span class="keywordflow">return</span>;

 Get a node
<a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* pElem = doc.FirstChildElement();
<span class="keywordflow">if</span> ( !pElem ) <span class="keywordflow">return</span>;

 Get the node we want
pElem = pElem-&gt;NextSibling();
<span class="keywordflow">if</span> ( !pElem ) <span class="keywordflow">return</span>;

 <span class="keywordflow">do</span> something useful here
</pre></div><p>An alternative was to use <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly useful thi...">TiXmlHandle</a>, which allows for function chaining by checking the intermediate function return values:</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> Load a document
<a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a> doc(pFilename);
<span class="keywordflow">if</span> (!doc.LoadFile()) <span class="keywordflow">return</span>;

 Make a document handle
<a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly useful thi...">TiXmlHandle</a> hDoc(&amp;doc);

 Get an element by <span class="keyword">using</span> the handle to chain calls
 Note the conversion of the <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly useful thi...">TiXmlHandle</a> to the <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* - .Element()
<a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* pElem = hDoc.FirstChildElement().NextSibling().Element();
<span class="keywordflow">if</span> ( !pElem ) <span class="keywordflow">return</span>;

 <span class="keywordflow">do</span> something useful here
</pre></div><p>With TinyXML++, if there is an error during a function call, it throws an exception. This means that a programmer can assume that every function is successful, as long as the functions are enclosed in a try-catch block.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">try</span>
{
 Load a document
    <a class="code" href="classticpp_1_1Document.html" title="Wrapper around TiXmlDocument.">ticpp::Document</a> doc( pFilename );
    doc.LoadFile();

 Get an element by chaining calls - no <span class="keywordflow">return</span> values to check, no <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly useful thi...">TiXmlHandle</a>
    <a class="code" href="classticpp_1_1Element.html" title="Wrapper around TiXmlElement.">ticpp::Element</a>* pElem = doc.<a class="code" href="classTiXmlNode.html#af4fb652f6bd79ae0d5ce7d0f7d3c0fba" title="Convenience function to get through elements.">FirstChildElement</a>()-&gt;<a class="code" href="classTiXmlNode.html#a1b94d2f7fa7ab25a5a8e8d4340c449c9" title="STL std::string form.">NextSibling</a>();

 <span class="keywordflow">do</span> something useful here
}
<span class="keywordflow">catch</span>( <a class="code" href="classticpp_1_1Exception.html" title="This is a ticpp exception class.">ticpp::Exception</a>&amp; ex )
{
 If any function has an error, execution will enter here.
 Report the error
    std::cout &lt;&lt; ex.<a class="code" href="classticpp_1_1Exception.html#aeac1f13b96eb4e1f2a3659dc9080edd6" title="Override std::exception::what() to return m_details.">what</a>();
}
</pre></div><h3>Use templates for automatic type conversion </h3>
<p>When using TinyXML, a programmer either needs to convert values to and from strings, or choose from one of many overloads to get the value in the desired type.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> Load a document
<a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a> doc( pFilename );
<span class="keywordflow">if</span> ( !doc.LoadFile() ) <span class="keywordflow">return</span>;

 Get a node
<a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* pElem = doc.FirstChildElement();
<span class="keywordflow">if</span> ( !pElem ) <span class="keywordflow">return</span>;

 Get the node we want
pElem = pElem-&gt;NextSibling();
<span class="keywordflow">if</span> ( !pElem ) <span class="keywordflow">return</span>;

 Get the attribute as a string, convert to <span class="keywordtype">int</span>
<span class="keyword">const</span> <span class="keywordtype">char</span>* pszAttr = pElem-&gt;Attribute( <span class="stringliteral">&quot;myAttribute&quot;</span> );
<span class="keywordtype">int</span> attr = atoi( pszAttr );

 Get the attribute as an <span class="keywordtype">int</span>
<span class="keywordtype">int</span> attr2;
<span class="keywordflow">if</span> ( TIXML_SUCCESS != pElem-&gt;QueryIntAttribute( <span class="stringliteral">&quot;myAttribute&quot;</span>, &amp;attr2 ) )
{
    <span class="keywordflow">return</span>;
}

 Get the attribute as a <span class="keywordtype">double</span>
<span class="keywordtype">double</span> attr3;
<span class="keywordflow">if</span> ( TIXML_SUCCESS != pElem-&gt;QueryDoubleAttribute( <span class="stringliteral">&quot;myAttribute&quot;</span>, &amp;attr3 ) )
{
    <span class="keywordflow">return</span>;
}

 Get the attribute as a <span class="keywordtype">float</span>
<span class="keywordtype">float</span> attr4;
<span class="keywordflow">if</span> ( TIXML_SUCCESS != pElem-&gt;QueryFloatAttribute( <span class="stringliteral">&quot;myAttribute&quot;</span>, &amp;attr4 ) )
{
    <span class="keywordflow">return</span>;
}
</pre></div><p>TinyXML++ uses templates for automatic type conversion.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">try</span>
{
 Load a document
    <a class="code" href="classticpp_1_1Document.html" title="Wrapper around TiXmlDocument.">ticpp::Document</a> doc( pFilename );
    doc.LoadFile();

 Get an element by chaining calls - no <span class="keywordflow">return</span> values to check, no <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly useful thi...">TiXmlHandle</a>
    <a class="code" href="classticpp_1_1Element.html" title="Wrapper around TiXmlElement.">ticpp::Element</a>* pElem = doc.FirstChildElement()-&gt;NextSibling();

 GetAttribute can determine the type of the pointer, and convert automatically

 Get the attribute as a <span class="keywordtype">string</span>
    std::string attr;
    pElem-&gt;GetAttribute( <span class="stringliteral">&quot;myAttribute&quot;</span>, &amp;attr );

 Get the attribute as an <span class="keywordtype">int</span>
    <span class="keywordtype">int</span> attr2;
    pElem-&gt;GetAttribute( <span class="stringliteral">&quot;myAttribute&quot;</span>, &amp;attr2 );

 Get the attribute as an <span class="keywordtype">float</span>
    <span class="keywordtype">float</span> attr3;
    pElem-&gt;GetAttribute( <span class="stringliteral">&quot;myAttribute&quot;</span>, &amp;attr3 );

 Get the attribute as an <span class="keywordtype">double</span>
    <span class="keywordtype">double</span> attr4;
    pElem-&gt;GetAttribute( <span class="stringliteral">&quot;myAttribute&quot;</span>, &amp;attr4 );

 Get the attribute as an <span class="keywordtype">bool</span>
    <span class="keywordtype">bool</span> attr5;
    pElem-&gt;GetAttribute( <span class="stringliteral">&quot;myAttribute&quot;</span>, &amp;attr5 );

}
<span class="keywordflow">catch</span>( <a class="code" href="classticpp_1_1Exception.html" title="This is a ticpp exception class.">ticpp::Exception</a>&amp; ex )
{
 If any function has an error, execution will enter here.
 Report the error
    std::cout &lt;&lt; ex.<a class="code" href="classticpp_1_1Exception.html#aeac1f13b96eb4e1f2a3659dc9080edd6" title="Override std::exception::what() to return m_details.">what</a>();
}
</pre></div> <h3>Use STL style iterators to move through nodes and attributes </h3>
<p>TinyXML has two ways to iterate:</p>
<p>First Method: </p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">for</span>( child = parent-&gt;FirstChild( <span class="keyword">false</span> ); child; child = child-&gt;NextSibling( <span class="keyword">false</span> ) )
</pre></div><p>Second Method: </p>
<div class="fragment"><pre class="fragment">    child = 0;
    <span class="keywordflow">while</span>( child = parent-&gt;IterateChildren( child ) )
</pre></div><p>Although both methods work quite well, the syntax is not familiar. TinyXML++ introduces iterators: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classticpp_1_1Iterator.html" title="Iterator for conveniently stepping through Nodes and Attributes.">ticpp::Iterator&lt; ticpp::Node &gt;</a> child;
<span class="keywordflow">for</span> ( child = child.<a class="code" href="classticpp_1_1Iterator.html#a056e73d1bed641f43114b9d4e9f0f29e" title="For for loop comparisons.">begin</a>( parent ); child != child.<a class="code" href="classticpp_1_1Iterator.html#a7b4a49c16cff8c8470cc5c9a63810cd5" title="For for loop comparisons.">end</a>(); child++ )
</pre></div><p>Iterators have the added advantage of filtering by type: </p>
<div class="fragment"><pre class="fragment"> Only iterates through Comment nodes
<a class="code" href="classticpp_1_1Iterator.html" title="Iterator for conveniently stepping through Nodes and Attributes.">ticpp::Iterator&lt; ticpp::Comment &gt;</a> child;
<span class="keywordflow">for</span> ( child = child.begin( parent ); child != child.end(); child++ )
</pre></div><div class="fragment"><pre class="fragment"> Only iterates through Element nodes with value <span class="stringliteral">&quot;ElementValue&quot;</span>
<a class="code" href="classticpp_1_1Iterator.html" title="Iterator for conveniently stepping through Nodes and Attributes.">ticpp::Iterator&lt; ticpp::Element &gt;</a> child( <span class="stringliteral">&quot;ElementValue&quot;</span> );
<span class="keywordflow">for</span> ( child = child.begin( parent ); child != child.end(); child++ )
</pre></div><p>Finally, Iterators also work with Attributes </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classticpp_1_1Iterator.html" title="Iterator for conveniently stepping through Nodes and Attributes.">ticpp::Iterator&lt; ticpp::Attribute &gt;</a> attribute;
<span class="keywordflow">for</span> ( attribute = attribute.<a class="code" href="classticpp_1_1Iterator.html#a056e73d1bed641f43114b9d4e9f0f29e" title="For for loop comparisons.">begin</a>( element ); attribute != attribute.<a class="code" href="classticpp_1_1Iterator.html#a7b4a49c16cff8c8470cc5c9a63810cd5" title="For for loop comparisons.">end</a>(); attribute++ )
</pre></div> </div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Oct 24 2011 10:23:25 for TinyXml by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
